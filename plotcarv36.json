{"README.md":"\r\n> このページを開く [https://itibanbosi.github.io/plotcarv31/](https://itibanbosi.github.io/plotcarv31/)\r\n\r\n## 拡張機能として使用\r\n\r\nこのリポジトリは、MakeCode で **拡張機能** として追加できます。\r\n\r\n* [https://makecode.microbit.org/](https://makecode.microbit.org/) を開く\r\n* **新しいプロジェクト** をクリックしてください\r\n* ギアボタンメニューの中にある **拡張機能** をクリックしてください\r\n* **https://github.com/itibanbosi/plotcarv31** を検索してインポートします。\r\n\r\n## このプロジェクトを編集します ![ビルド ステータス バッジ](https://github.com/itibanbosi/plotcarv31/workflows/MakeCode/badge.svg)\r\n\r\nMakeCode でこのリポジトリを編集します。\r\n\r\n* [https://makecode.microbit.org/](https://makecode.microbit.org/) を開く\r\n* **読み込む** をクリックし、 **URLから読み込む...** をクリックしてください\r\n* **https://github.com/itibanbosi/plotcarv31** を貼り付けてインポートをクリックしてください\r\n\r\n## ブロックのプレビュー\r\n\r\nこの画像はマスター内の最後のコミットからのブロックコードを示しています。\r\nこのイメージは更新に数分かかる場合があります。\r\n\r\n![生成されたブロック](https://github.com/itibanbosi/plotcarv31/raw/master/.github/makecode/blocks.png)\r\n\r\n#### メタデータ (検索、レンダリングに使用)\r\n\r\n* for PXT/microbit\r\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\r\n\r\n\r\n\r\n> このページを開く [https://itibanbosi.github.io/pxt-plotcarv35/](https://itibanbosi.github.io/pxt-plotcarv35/)\r\n\r\n## 拡張機能として使用\r\n\r\nこのリポジトリは、MakeCode で **拡張機能** として追加できます。\r\n\r\n* [https://makecode.microbit.org/](https://makecode.microbit.org/) を開く\r\n* **新しいプロジェクト** をクリックしてください\r\n* ギアボタンメニューの中にある **拡張機能** をクリックしてください\r\n* **https://github.com/itibanbosi/pxt-plotcarv35** を検索してインポートします。\r\n\r\n## このプロジェクトを編集します ![ビルド ステータス バッジ](https://github.com/itibanbosi/pxt-plotcarv35/workflows/MakeCode/badge.svg)\r\n\r\nMakeCode でこのリポジトリを編集します。\r\n\r\n* [https://makecode.microbit.org/](https://makecode.microbit.org/) を開く\r\n* **読み込む** をクリックし、 **URLから読み込む...** をクリックしてください\r\n* **https://github.com/itibanbosi/pxt-plotcarv35** を貼り付けてインポートをクリックしてください\r\n\r\n## ブロックのプレビュー\r\n\r\nこの画像はマスター内の最後のコミットからのブロックコードを示しています。\r\nこのイメージは更新に数分かかる場合があります。\r\n\r\n![生成されたブロック](https://github.com/itibanbosi/pxt-plotcarv35/raw/master/.github/makecode/blocks.png)\r\n\r\n#### メタデータ (検索、レンダリングに使用)\r\n\r\n* for PXT/microbit\r\n<script src=\"https://makecode.com/gh-pages-embed.js\"></script><script>makeCodeRender(\"{{ site.makecode.home_url }}\", \"{{ site.github.owner_name }}/{{ site.github.repository_name }}\");</script>\r\n","_locales/ja/plotcarv36-strings.json":"{\n  \"plot.auto_led_off|block\": \"ﾏｲｸﾛﾋﾞｯﾄLED |%Matrix_LED|\",\n  \"plot.color1|block\": \"|%scene|色 \",\n  \"plot.color_ID|block\": \"color ID\",\n  \"plot.color_scene.Blue|block\": \"青\",\n  \"plot.color_scene.Green|block\": \"緑\",\n  \"plot.color_scene.Red|block\": \"赤\",\n  \"plot.color_scene.White|block\": \"白\",\n  \"plot.color_senser.Blue|block\": \"青\",\n  \"plot.color_senser.Green|block\": \"緑\",\n  \"plot.color_senser.Light|block\": \"白\",\n  \"plot.color_senser.Red|block\": \"赤\",\n  \"plot.color_temp|block\": \"色温度\",\n  \"plot.colorcycle.cycle10|block\": \"cycle10\",\n  \"plot.colorcycle.cycle1|block\": \"cycle1\",\n  \"plot.colorcycle.cycle256|block\": \"cycle256\",\n  \"plot.colorcycle.cycle42|block\": \"cycle42\",\n  \"plot.colorcycle.cycle64|block\": \"cylce64\",\n  \"plot.colorgain.gain16|block\": \"16×gain\",\n  \"plot.colorgain.gain1|block\": \"1×gain\",\n  \"plot.colorgain.gain4|block\": \"4×gain\",\n  \"plot.colorgain.gain60|block\": \"60×gain\",\n  \"plot.colorsenser_value|block\": \"|%color|値\",\n  \"plot.continuous_houkou.Stop|block\": \"停止\",\n  \"plot.continuous_houkou.backward|block\": \"後ろ\",\n  \"plot.continuous_houkou.forward|block\": \"前\",\n  \"plot.continuous_houkou.front__Left|block\": \"前左\",\n  \"plot.continuous_houkou.front_right|block\": \"前右\",\n  \"plot.continuous_houkou.left_rotation|block\": \"左回転\",\n  \"plot.continuous_houkou.right_rotation|block\": \"右回転\",\n  \"plot.continuous_operation2|block\": \"連続|%operation|　時間|%time_sec|(秒)\",\n  \"plot.continuous_operation1|block\": \"連続|%operation|\",\n  \"plot.cycle|block\": \"円の作図　回転方向|%RorL|,直径|%D_Num|cm\",\n  \"plot.driveForwards|block\": \"待ち時間 (秒)|%second|\",\n  \"plot.houkou.diagonal_left|block\": \"左ななめ前\",\n  \"plot.houkou.diagonal_right|block\": \"右ななめ前\",\n  \"plot.houkou.left_angle|block\": \"左へ直角\",\n  \"plot.houkou.right_angle|block\": \"右へ直角\",\n  \"plot.kyori.long|block\": \"長い\",\n  \"plot.kyori.short|block\": \"短い\",\n  \"plot.microbit2_decideLight|block\": \"ﾏｲｸﾛﾋﾞｯﾄの明るさｾﾝｻｰが|%limit|より暗い\",\n  \"plot.microbit2_denkitemp|block\": \"ﾏｲｸﾛﾋﾞｯﾄの明るさｾﾝｻｰ値\",\n  \"plot.microbit_LED.activate|block\": \"有効\",\n  \"plot.microbit_LED.disable|block\": \"無効\",\n  \"plot.onoff.OFF|block\": \"OFF\",\n  \"plot.onoff.ON|block\": \"ON\",\n  \"plot.pen_updown.down2|block\": \"下げる(新型 底にｻｰﾎﾞﾓｰﾀｰ)\",\n  \"plot.pen_updown.down|block\": \"下げる(上にｻｰﾎﾞﾓｰﾀｰ)\",\n  \"plot.pen_updown.up|block\": \"上げる\",\n  \"plot.photo_LR_out|block\": \"左右とも|%wb|をふんでいる時　感度|%sikii| \",\n  \"plot.photo_L_out|block\": \"左だけが|%wb|をふんでいる時　感度|%sikii| \",\n  \"plot.photo_L|block\": \"左ﾌｫﾄﾘﾌﾚｸﾀｰ　|%limit_L|より小さい\",\n  \"plot.photo_R_out|block\": \"右だけが|%wb|をふんでいる時　感度|%sikii| \",\n  \"plot.photo_R|block\": \"右ﾌｫﾄﾘﾌﾚｸﾀｰ　|%limit_R|より小さい\",\n  \"plot.phto_L|block\": \"左ﾌｫﾄﾘﾌﾚｸﾀｰ\",\n  \"plot.phto_R|block\": \"右ﾌｫﾄﾘﾌﾚｸﾀｰ\",\n  \"plot.plotcar_speed|block\": \"ﾌﾟﾛｯﾄｶｰの動作ｽﾋﾟｰﾄﾞ ゆっくり|%plotcarspeed|速い\",\n  \"plot.plotter_Distance|block\": \"進行距離調整(1/1000) 少ない|%Dis|多い\",\n  \"plot.plotter_RL.left|block\": \"左\",\n  \"plot.plotter_RL.right|block\": \"右\",\n  \"plot.plotter_degree|block\": \"回転量調整(1/1000) 少ない|%Deg|多い\",\n  \"plot.plotter_houkou.backward|block\": \"後ろ\",\n  \"plot.plotter_houkou.forward|block\": \"前\",\n  \"plot.car_L_step|block\": \"左車輪|%houkou|へ |%L_step|ステップ\",\n  \"plot.car_RL_cycle|block\": \"回転|%L_degree|度　|%RorL|まわり\",\n  \"plot.car_R_step|block\": \"右車輪|%houkou|へ |%R_step|ステップ\",\n  \"plot.car_frest|block\": \"電源OFF\",\n  \"plot.car_houkou|block\": \"|%muki|へ方向を変える\",\n  \"plot.car_pen|block\": \"ペン|%mode| \",\n  \"plot.car_zengo|block\": \"|%zengo|へ |%F_cm|cm進む\",\n  \"plot.polygon|block\": \"多角形の作図 回転方向|%RorL|,|%digree_step|角形,辺の長さ|%Edge_Num|cm\",\n  \"plot.sence_select.High_sensitivity|block\": \"明るい部屋\",\n  \"plot.sence_select.Low_sensitivity|block\": \"暗い部屋\",\n  \"plot.sence_select.normal30|block\": \"普通の部屋\",\n  \"plot.sonar_ping_2|block\": \"距離ｾﾝｻｰ\",\n  \"plot.sonar_ping_3|block\": \"(最小 5cm) きょり|%limit|cmより|%nagasa| \",\n  \"plot.whiteblack.black|block\": \"黒\",\n  \"plot.whiteblack.white|block\": \"白\",\n  \"plotLED_blocks.neopixel_Brightness_block|block\": \"Color LED(s) Brightness|%neo_Brightness| \",\n  \"plotLED_blocks.neopixel_erace_block|block\": \"ﾌﾙｶﾗｰLEDを全部消す\",\n  \"plotLED_blocks.neopixel_rainbow|block\": \"にじ色\",\n  \"plotLED_blocks.neopixel_select_block|block\": \"|%neo_number|個のLED   $color 色\",\n  \"plotLED_blocks.neopixel_set_block|block\": \"No.|%neo_number|番目のLED $color 色\",\n  \"{id:category}plot\": \"プロットカー\",\n  \"{id:category}PlotLED_blocks\": \"プロットカーLED\",\n  \"{id:group}1 Control Pen\": \"1 ペンのじょうたい\",\n    \"{id:group}2 Basic control\": \"2 基本の動き\",\n  \"{id:group}3 Shape\": \"3 図形\",\n  \"{id:group}4 Default setting\": \"4 初期設定\",\n  \"{id:group}5 Fine control\": \"5 調整\",\n  \"{id:group}6 Ultrasonic_Distance sensor\": \"6 超音波きょりｾﾝｻｰ\",\n  \"{id:group}7 photoreflector\": \"7 反射型光ｾﾝｻｰ\",\n  \"{id:group}8 color senser\": \"8 ｶﾗｰｾﾝｻ\",\n  \"{id:group}8 microbit Optical_sensor\": \"9 ﾏｲｸﾛﾋﾞｯﾄ上の光ｾﾝｻｰ\",\n  \"{id:group}color LED\": \"color LED\"\n}","main.blocks":"<xml xmlns=\"https://developers.google.com/blockly/xml\"><variables><variable id=\"-%zi6?Z!`tRJKc-[n1,P\">strip</variable><variable id=\"id6=2t2`UF^rTbs%IFs-\">選択</variable></variables><block type=\"pxt-on-start\" id=\"UM-K818.bb?~0A]8}(`j\" x=\"17\" y=\"-1\"/><block type=\"device_forever\" id=\"bu#:S%Ps~2S}r0tq]stD\" x=\"196\" y=\"5\"/><block type=\"device_button_event\" id=\"cEGt4U()qlXrm/l6TB=V\" x=\"23\" y=\"124\"><field name=\"NAME\">Button.A</field></block></xml>","main.ts":"input.onButtonPressed(Button.A, function () {\r\n\t\r\n})\r\nbasic.forever(function () {\r\n\t\r\n})\r\n","plotcarv36.ts":"/* plot Ver5.2 2023/12/11 \r\n　カラーセンサー対応\r\n　連続の前進・回転　対応\r\n　ペンの上げ下げ　変更\r\n   eureka.niigata.jp  */\r\n   \r\n   let wait = 0;\r\n   let Tugi_R = 0;\r\n   let Tugi_L = 0;\r\n   let T1 = 0;\r\n   let PremotionR = 0;\r\n   let PremotionL = 0;\r\n   let con_kaiten = 1.61;\r\n   let cond_Distance = 1;\r\n   let cond_degree = 1;\r\n   let microbit_wait = 750;\r\n   let Stepping_non = 0\r\n   let SteppingF_0 = 207854691 /* 0b1100011000111001110001100011 */\r\n   let SteppingB_0 = 154585398  /*0b1001001101101100100100110110 */\r\n   let Stepping_R = 0\r\n   let Stepping_L = 0\r\n   let original_bit = 8     /* 1000 */\r\n   let outputsR = [DigitalPin.P3, DigitalPin.P4, DigitalPin.P6, DigitalPin.P7]\r\n   let outputsL = [DigitalPin.P13, DigitalPin.P14, DigitalPin.P15, DigitalPin.P16];\r\n   let sikii1 = 55\r\n   let con_ope = 0\r\n\r\n   \r\n   //LED不使用\r\n   led.enable(false)\r\n   \r\n   basic.pause(300);\r\n   pins.servoWritePin(AnalogPin.P8, 70);\r\n   basic.pause(300);\r\n   pins.digitalWritePin(DigitalPin.P8,0);\r\n\r\n   enum onoff {\r\n    ON,\r\n    OFF\r\n}\r\n\r\nenum position {\r\n    front,\r\n    rear\r\n}\r\n\r\n\r\n    let color_cycle = 10;\r\n    let neo_sinamon = neopixel.create(DigitalPin.P9, 2, NeoPixelMode.RGB)\r\n    neo_sinamon.setBrightness(20)\r\n   \r\n   for (let n = 0; n < 4; n++) {\r\n       (outputsR[n], 0)\r\n       pins.digitalWritePin(outputsL[n], 0)\r\n   }\r\n   \r\n   let moter_number = 0;\r\n   let io_neo = neopixel.create(DigitalPin.P9, 4, NeoPixelMode.RGB);\r\n   io_neo.setBrightness(80)\r\n   io_neo.easeBrightness()\r\n   io_neo.showRainbow(1, 360)\r\n   \r\n   \r\n   //バージョンの判定\r\n   let first = input.runningTimeMicros()\r\n   let sum = 0\r\n   for (let index = 0; index < 1000; index++) {\r\n       sum += 1\r\n   }\r\n   //basic.showNumber(input.runningTimeMicros() - first);\r\n   if ((input.runningTimeMicros() - first) < 2000) {\r\n       microbit_wait = 4500;\r\n   }\r\n   else {\r\n       microbit_wait = 900;\r\n   }\r\n   \r\n   \r\n   \r\n   //% color=\"#3943c6\" block=\"Plotcar Ver5.1\" weight=95 icon=\"\\uf1b9\"\r\n   namespace plot {\r\n   \r\n       export enum pen_updown {\r\n           //% block=\"down\"\r\n           down,\r\n            //% block=\"up\"\r\n            up,\r\n           //% block=\"(NewPlotcar) down\"\r\n           down2\r\n       }\r\n   \r\n       export enum plotter_houkou {\r\n           //% block=\"forward\"\r\n           forward,\r\n           //% block=\"backward\"\r\n           backward\r\n       }\r\n   \r\n       export enum plotter_RL {\r\n           //% block=\"right\"\r\n           right,\r\n           //% block=\"left\"\r\n           left\r\n       }\r\n   \r\n   \r\n       export enum microbit_LED {\r\n           //% block=\"disable\"\r\n           disable,\r\n           //% block=\"activate\"\r\n           activate\r\n       }\r\n   \r\n       export enum houkou {\r\n           //% block=\"right_angle\"\r\n           right_angle,\r\n           //% block=\"left_angle\"\r\n           left_angle,\r\n           //% block=\"diagonal_right\"\r\n           diagonal_right,\r\n           //% block=\"diagonal_left\"\r\n           diagonal_left\r\n       }\r\n   \r\n       export enum continuous_houkou{\r\n            //% block=\"forward\"\r\n            forward,\r\n            //% block=\"backward\"\r\n            backward,\r\n           //% block=\"right_rotation\"\r\n           right_rotation,\r\n           //% block=\"left_rotation\"\r\n           left_rotation,\r\n           //% block=\"front_Right\"\r\n           front_right,\r\n           //% block=\"front_Left\"\r\n           front__Left,\r\n           //% block=\"Stop\"\r\n           Stop\r\n\r\n\r\n       }\r\n\r\n\r\n   \r\n       export enum kyori {\r\n           //% block=\"long\"\r\n           long,\r\n           //% block=\"short\",\r\n           short\r\n       }\r\n       export enum sence_select {\r\n           //% block=\"normal30\"\r\n           normal30,\r\n           //% block=\"High_sensitivity\"\r\n           High_sensitivity,\r\n           //% block=\"Low_sensitivity\",\r\n           Low_sensitivity\r\n       }\r\n   \r\n   \r\n       export enum onoff {\r\n           //% block=\"ON\"\r\n           ON,\r\n           //% block=\"OFF\"\r\n           OFF\r\n       }\r\n       export enum whiteblack {\r\n           //% block=\"black\"\r\n           black,\r\n           //% block=\"white\"\r\n           white\r\n       }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n       export enum color_senser {\r\n        //% block=\"Red\"\r\n        Red,\r\n        //% block=\"Green\",\r\n        Green,\r\n        //% block=\"Blue\",\r\n        Blue,\r\n        //% block=\"Light\",\r\n        Light              \r\n    }    \r\n\r\n\r\n    export enum color_scene {\r\n        //% block=\"Red\"\r\n        Red,\r\n        //% block=\"Green\",\r\n        Green,\r\n        //% block=\"Blue\",\r\n        Blue,\r\n        //% block=\"White\"\r\n        White        \r\n    }  \r\n\r\n\r\n\r\n\r\n\r\n    export enum colorcycle {\r\n        //% block=\"cycle1\"\r\n        cycle1,\r\n        //% block=\"cycle10\",\r\n        cycle10,\r\n        //% block=\"cycle42\",\r\n        cycle42,\r\n        //% block=\"cylce64\",\r\n        cycle64\r\n    }\r\n\r\n    export enum colorgain {\r\n        //% block=\"1×gain\"\r\n        gain1,\r\n        //% block=\"4×gain\",\r\n        gain4,\r\n        //% block=\"16×gain\",\r\n        gain16,\r\n        //% block=\"60×gain\",\r\n        gain60\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n   \r\n       function moter(kyori: number, R_zengo: number, L_zengo: number) {\r\n           led.enable(false);\r\n           let i = 0;\r\n           /* 端数の計算計算  */\r\n   \r\n           let kyori_hasuu = kyori % 1;\r\n           let kyori_seisuu = Math.floor(kyori);\r\n   \r\n           /* forward回の動作との比較と処理  */\r\n           if (PremotionR == R_zengo) {\r\n               Tugi_R = Tugi_R + 1;\r\n           }\r\n           if (PremotionR > R_zengo) {\r\n               Tugi_R = 3 - Tugi_R + 1;\r\n           }\r\n           if (PremotionR < R_zengo) {\r\n               Tugi_R = 3 - Tugi_R + 1;\r\n           }\r\n   \r\n           if (PremotionL == L_zengo) {\r\n               Tugi_L = Tugi_L + 1;\r\n           }\r\n           if (PremotionL > L_zengo) {\r\n               Tugi_L = 3 - Tugi_L + 1;\r\n           }\r\n           if (PremotionL < L_zengo) {\r\n               Tugi_L = 3 - Tugi_L + 1;\r\n           }\r\n   \r\n   \r\n           /*   次のstep*/\r\n           Tugi_L = (Tugi_L) % 4;\r\n           Tugi_R = (Tugi_R) % 4;\r\n   \r\n           /*右ステッピングの処理*/\r\n           switch (R_zengo) {\r\n               case 0:\r\n                   Stepping_R = Stepping_non;\r\n                   break;\r\n               case 1:\r\n                   Stepping_R = SteppingB_0 << (Tugi_R*4)\r\n                   break;\r\n               case 2:\r\n                   Stepping_R = SteppingF_0 << (Tugi_R*4)\r\n                   break;\r\n           }\r\n           Stepping_L = SteppingF_0\r\n           /*左ステッピングの処理*/\r\n           switch (L_zengo) {\r\n               case 0:\r\n                   Stepping_L = Stepping_non;\r\n                   break;\r\n               case 1:\r\n                   Stepping_L = SteppingF_0 << (Tugi_L * 4)\r\n                   break;\r\n               case 2:\r\n                   Stepping_L = SteppingB_0 << (Tugi_L * 4)\r\n                   break;\r\n           }\r\n   \r\n           /*  バックラッシュの処理　right_wheel*/\r\n           if (PremotionR != R_zengo) {\r\n               /*music.playTone(523, music.beat(BeatFraction.Sixteenth))*/\r\n               basic.pause(300);\r\n               for (let index = 0; index < 3; index++) {\r\n                   let n = 0;\r\n                   while (n < 4) {\r\n                       for (let m = 0; m < 4; m++) {\r\n                           pins.digitalWritePin(outputsR[m], (((Stepping_R >> (24 - n * 4)) & (original_bit >> m)) >> (3 - m)));\r\n                       }\r\n                       n = n + 1;\r\n                       for (i = 0; i < microbit_wait; i++);\r\n                       {\r\n                       }\r\n                   }\r\n               }\r\n               basic.pause(200);\r\n           }\r\n   \r\n   \r\n           /*  バックラッシュの処理　left_wheel*/\r\n           if (PremotionL != L_zengo) {\r\n               /*music.playTone(523, music.beat(BeatFraction.Sixteenth))*/\r\n               basic.pause(300);\r\n               for (let index = 0; index < 3; index++) {\r\n                   let n = 0;\r\n                   while (n < 4) {\r\n                       for (let m = 0; m < 4; m++) {\r\n                           pins.digitalWritePin(outputsL[m], (((Stepping_L >> (24 - n * 4)) & (original_bit >> m)) >> (3 - m)));\r\n                       }\r\n                       n = n + 1;\r\n                       for (i = 0; i < microbit_wait; i++);\r\n                       {\r\n                       }\r\n                   }\r\n               }\r\n   \r\n           }\r\n   \r\n   \r\n           /*  整数部の処理　 */\r\n           for (let index = 0; index < kyori_seisuu; index++) {\r\n               for (let n = 0; n < 4; n++) {\r\n                   for (let m = 0; m < 4; m++) {\r\n                       pins.digitalWritePin(outputsL[m], (((Stepping_L >> (24 - n * 4)) & (original_bit >> m)) >> (3-m)));\r\n                       pins.digitalWritePin(outputsR[m], (((Stepping_R >> (24 - n * 4)) & (original_bit >> m)) >> (3-m)));\r\n                   }\r\n                   for (let i = 0; i < microbit_wait; i++);\r\n                   {\r\n                   }\r\n               }\r\n           }\r\n   \r\n   \r\n           /* 端数分の進み方と処理  */\r\n           let Step_number = Math.floor(kyori_hasuu * 10 / 2.5);\r\n           let n = 0;\r\n           while (n < Step_number) {\r\n               for (let m = 0; m < 4; m++) {\r\n                    pins.digitalWritePin(outputsL[m], (((Stepping_L >> (24 - n * 4)) & (original_bit >> m)) >> (3 - m)));\r\n                   pins.digitalWritePin(outputsR[m], (((Stepping_R >> (24 - n * 4)) & (original_bit >> m)) >> (3 - m)));\r\n               }\r\n               n = n + 1;\r\n               for (i = 0; i < microbit_wait; i++);\r\n               {\r\n               }\r\n           }\r\n   \r\n           Tugi_L = (Tugi_L + n - 1) % 4;\r\n           Tugi_R = (Tugi_R + n - 1) % 4;\r\n   \r\n           PremotionR = R_zengo;\r\n           PremotionL = L_zengo;\r\n           for (let n = 0; n < 4; n++) {\r\n               pins.digitalWritePin(outputsR[n], 0)\r\n               pins.digitalWritePin(outputsL[n], 0)\r\n           }\r\n       }\r\n   \r\n   \r\n       //% color=\"#ff1493\" weight=96 blockId=eureka_relay block=\"pen |%mode| \" group=\"1 Control Pen\"\r\n       export function car_pen(mode: pen_updown) {\r\n           if (mode == pen_updown.up) {\r\n               pins.servoWritePin(AnalogPin.P8, 70);\r\n               basic.pause(1000);\r\n               pins.digitalWritePin(DigitalPin.P8, 0)\r\n           }\r\n           if (mode == pen_updown.down) {\r\n               pins.servoWritePin(AnalogPin.P8, 0);\r\n               basic.pause(300);\r\n           }\r\n           if (mode == pen_updown.down2) {\r\n               pins.servoWritePin(AnalogPin.P8, 45);\r\n               basic.pause(300);\r\n           }\r\n   \r\n       }\r\n\r\n    //% color=\"#1E90FF\" weight=93 block=\"Wait time (sec)|%second|\" group=\"2 Basic control\"\r\n    //% second.min=0 second.max=10 second.defl=1\r\n    export function driveForwards(second: number): void {\r\n        basic.pause(second * 1000);\r\n    }\r\n\r\n\r\n       /*\r\n       //% color=\"#ff1493\" weight=90 blockId=eureka_relay2 block=\"New_pen |%mode| \" group=\"1 Control Pen\"\r\n       export function car_pen2(mode: pen_updown) {\r\n           if (mode == pen_updown.up) {\r\n               pins.servoWritePin(AnalogPin.P8, 80);\r\n               basic.pause(1000);\r\n           }\r\n   \r\n           if (mode == pen_updown.down) {\r\n               pins.servoWritePin(AnalogPin.P8, 45);\r\n               basic.pause(300);\r\n           }\r\n       }\r\n   */\r\n       //% color=\"#3943c6\" weight=80 blockId=car_zengo\r\n       //% block=\"Move |%zengo| |%F_cm| cm\" group=\"2 Basic control\"\r\n       export function car_zengo(zengo: plotter_houkou, F_cm: number): void {\r\n           switch (zengo) {\r\n               case plotter_houkou.forward:\r\n                   moter_number = F_cm / (18.9 * cond_Distance) * 512;\r\n                   moter(moter_number, 1, 1);\r\n                   break;\r\n   \r\n               case plotter_houkou.backward:\r\n                   moter_number = F_cm / (18.9 * cond_Distance) * 512;\r\n                   moter(moter_number, 2, 2);\r\n                   break;\r\n           }\r\n       }\r\n   \r\n       //% color=\"#3943c6\" weight=76 blockId=car_RL_cycle\r\n       //% block=\"Rotate |%L_degree|degrees to |%RorL|\" group=\"2 Basic control\"\r\n       export function car_RL_cycle(RL_degree: number, RorL: plotter_RL): void {\r\n           switch (RorL) {\r\n               case plotter_RL.left:\r\n                   moter_number = RL_degree / 360 * 512 * con_kaiten * cond_degree;\r\n                   moter(moter_number, 1, 2);\r\n                   break;\r\n               case plotter_RL.right:\r\n                   moter_number = RL_degree / 360 * 512 * con_kaiten * cond_degree;\r\n                   moter(moter_number, 2, 1);\r\n                   break;\r\n           }\r\n       }\r\n   \r\n /*  \r\n       //% color=\"#ff4940\" weight=71 blockId=car_rest\r\n       //% block=\"power off\" group=\"2 Basic control\"\r\n       export function car_frest(): void {\r\n           moter_number = 1;\r\n           moter(moter_number, 0, 1);\r\n       }\r\n   \r\n */  \r\n   \r\n   \r\n       //% color=\"#3943c6\" weight=72 blockId=_houkou\r\n       //% block=\"change direction to|%muki|\" group=\"2 Basic control\"\r\n       export function car_houkou(muki: houkou): void {\r\n           switch (muki) {\r\n               case houkou.right_angle:\r\n                   return plot.car_RL_cycle(90, plotter_RL.right);\r\n               case houkou.left_angle:\r\n                   return plot.car_RL_cycle(90, plotter_RL.left);\r\n               case houkou.diagonal_right:\r\n                   return plot.car_RL_cycle(45, plotter_RL.right);\r\n               case houkou.diagonal_left:\r\n                   return plot.car_RL_cycle(45, plotter_RL.left);\r\n           }\r\n       }\r\n   \r\n   \r\n       //% color=\"#3943c6\" weight=60 blockId=continuous_operation1\r\n       //% block=\"continuous |%operation|\" group=\"2 Basic control\"\r\n       export function continuous_operation1(operation:continuous_houkou ): void {\r\n           switch (operation) {\r\n            case continuous_houkou.forward:\r\n                 con_ope = 1\r\n                 basic.pause(200);\r\n                 con_ope = 0\r\n                 break;\r\n             case continuous_houkou.backward:\r\n                 con_ope = 2\r\n                 basic.pause(200);\r\n                 con_ope = 0\r\n                 break;\r\n             case continuous_houkou.right_rotation:\r\n                 con_ope = 3\r\n                 basic.pause(200);\r\n                 con_ope = 0\r\n                break;\r\n             case continuous_houkou.left_rotation:\r\n                 con_ope = 4\r\n                 basic.pause(200);\r\n                 con_ope = 0\r\n                 break;\r\n             case continuous_houkou.front_right:\r\n                 con_ope = 5\r\n                 basic.pause(200);\r\n                 con_ope = 0                 \r\n                 break;\r\n             case continuous_houkou.front__Left:\r\n                 con_ope = 6\r\n                 basic.pause(200);\r\n                 con_ope = 0\r\n                 break;               \r\n             }\r\n    }\r\n\r\n\r\n       //% color=\"#3943c6\" weight=60 blockId=continuous_operation2\r\n       //% block=\"continuous |%operation| time |%time_sec|(sec)\" group=\"2 Basic control\"\r\n       export function continuous_operation2(operation:continuous_houkou ,time_sec:number): void {\r\n        switch (operation) {\r\n            case continuous_houkou.forward:\r\n                 con_ope = 1\r\n                 basic.pause(time_sec * 1000);\r\n                 con_ope = 0\r\n                 break;\r\n             case continuous_houkou.backward:\r\n                 con_ope = 2\r\n                 basic.pause(time_sec * 1000);\r\n                 con_ope = 0\r\n                 break;\r\n             case continuous_houkou.right_rotation:\r\n                 con_ope = 3\r\n                 basic.pause(time_sec * 1000);\r\n                 con_ope = 0\r\n                break;\r\n             case continuous_houkou.left_rotation:\r\n                 con_ope = 4\r\n                 basic.pause(time_sec * 1000);\r\n                 con_ope = 0\r\n                 break;\r\n             case continuous_houkou.front_right:\r\n                 con_ope = 5\r\n                 basic.pause(time_sec * 1000);\r\n                 con_ope = 0                 \r\n                 break;\r\n             case continuous_houkou.front__Left:\r\n                 con_ope = 6\r\n                 basic.pause(time_sec * 1000);\r\n                 con_ope = 0\r\n                 break;               \r\n             }\r\n    }\r\n\r\n\r\n\r\n   \r\n       //% color=\"#009A00\" weight=40 blockId=polygon\r\n       //% block=\"Run |%RorL|,|%digree_step| sides polygon,|%Edge_Num|cm length\" group=\"3 Shape\"\r\n       export function polygon(RorL: plotter_RL, digree_step: number, Edge_Num: number): void {\r\n           switch (RorL) {\r\n               case plotter_RL.right:\r\n                   for (let index = 0; index < digree_step; index++) {\r\n                       plot.car_zengo(plotter_houkou.forward, Edge_Num)\r\n                       plot.car_RL_cycle(360 / digree_step, plotter_RL.right)\r\n                   }\r\n                   break;\r\n               case plotter_RL.left:\r\n                   for (let index = 0; index < digree_step; index++) {\r\n                       plot.car_zengo(plotter_houkou.forward, Edge_Num)\r\n                       plot.car_RL_cycle(360 / digree_step, plotter_RL.left)\r\n                   }\r\n                   break;\r\n           }\r\n       }\r\n   \r\n   \r\n       //% color=\"#009A00\" weight=39 blockId=cycle\r\n       //% block=\"circlate |%RorL|,dia.|%D_Num|cm\" group=\"3 Shape\"\r\n       export function cycle(RorL: plotter_RL, D_Num: number): void {\r\n           let cir = D_Num * 3.14\r\n           let forward_D = cir / 30\r\n           switch (RorL) {\r\n               case plotter_RL.right:\r\n                   for (let index = 0; index < 30; index++) {\r\n                       plot.car_zengo(plotter_houkou.forward, forward_D)\r\n                       plot.car_RL_cycle(360 / 30, plotter_RL.right)\r\n                   }\r\n                   break;\r\n               case plotter_RL.left:\r\n                   for (let index = 0; index < 30; index++) {\r\n                       plot.car_zengo(plotter_houkou.forward, forward_D)\r\n                       plot.car_RL_cycle(360 / 30, plotter_RL.left)\r\n                   }\r\n   \r\n           }\r\n       }\r\n   \r\n       //% color=\"#ff3d03\" weight=34 blockId=plotcar_speed block=\"motion speed slow|%plotcarspeed|fast\" group=\"4 Default setting\"\r\n       //% plotcarspeed.min=-2000 plotcarspeed.max=40\r\n       export function plotcar_speed(plotcarspeed:number) :void{\r\n           microbit_wait = microbit_wait*(100-plotcarspeed)/100\r\n       }\r\n   \r\n       //% color=\"#ff3d03\" weight=35 blockId=auto_led_off block=\"micro:bit LED |%Matrix_LED|\" group=\"4 Default setting\"\r\n       export function auto_led_off(Matrix_LED: microbit_LED) {\r\n           switch (Matrix_LED) {\r\n               case microbit_LED.disable:\r\n                   led.enable(false);\r\n                   break;\r\n               case microbit_LED.activate:\r\n                   led.enable(true);\r\n           }\r\n       }\r\n       //% color=\"#ffa800\" weight=20 blockId=plotter_Distance\r\n       //% block=\"Travel distance adjustment(1/1000) shorter|%Dis|longer\" group=\"5 Fine control\"\r\n       //% Dis.min=-20 Dis.max=20\r\n       export function plotter_Distance(Dis: number): void {\r\n           cond_Distance = (1 + Dis / 1000);\r\n       }\r\n   \r\n       //% color=\"#ffa800\" weight=18 blockId=plotter_degree\r\n       //% block=\"Rotation angle adjustment(1/1000) Less|%Deg|more\" group=\"5 Fine control\"\r\n       //% Deg.min=-20 Deg.max=20\r\n       export function plotter_degree(Deg: number): void {\r\n           cond_degree = (1 + Deg / 1000);\r\n       }\r\n   \r\n       //% color=\"#3943c6\" weight=55 blockId=car_R_step\r\n       //% block=\"Right_wheel move |%houkou| |%R_step|steps\" group=\"5 Fine control\"\r\n   \r\n       export function car_R_step(houkou: plotter_houkou, R_step: number): void {\r\n           moter_number = R_step;\r\n           switch (houkou) {\r\n               case plotter_houkou.forward:\r\n                   moter(R_step / 4, 1, 0);\r\n                   return;\r\n               case plotter_houkou.backward:\r\n                   moter(R_step / 4, 2, 0);\r\n                   return;\r\n           }\r\n       }\r\n       //% color=\"#3943c6\" weight=58 blockId=car_L_step\r\n       //% block=\"Left wheel move |%houkou| |%L_step|steps\" group=\"5 Fine control\"\r\n       export function car_L_step(houkou: plotter_houkou, L_step: number): void {\r\n           moter_number = L_step;\r\n           switch (houkou) {\r\n               case plotter_houkou.forward:\r\n                   moter(L_step / 4, 0, 1);\r\n                   return;\r\n               case plotter_houkou.backward:\r\n                   moter(L_step / 4, 0, 2);\r\n                   return;\r\n           }\r\n       }\r\n   \r\n   \r\n   \r\n   \r\n   \r\n       //% color=\"#009A00\" weight=22 blockId=sonar_ping_2 block=\"Distance sensor\" group=\"6 Ultrasonic_Distance sensor\"\r\n       //% advanced=true\r\n       export function sonar_ping_2(): number {\r\n           let d1 = 0;\r\n           let d2 = 0;\r\n   \r\n           for (let i = 0; i < 5; i++) {\r\n               // send\r\n               basic.pause(5);\r\n               pins.setPull(DigitalPin.P2, PinPullMode.PullNone);\r\n               pins.digitalWritePin(DigitalPin.P2, 0);\r\n               control.waitMicros(2);\r\n               pins.digitalWritePin(DigitalPin.P2, 1);\r\n               control.waitMicros(10);\r\n               pins.digitalWritePin(DigitalPin.P2, 0);\r\n               // read\r\n               d1 = pins.pulseIn(DigitalPin.P0, PulseValue.High, 500 * 58);\r\n               d2 = d2 + d1;\r\n           }\r\n           return Math.round(Math.idiv(d2 / 5, 58) * 1.5);\r\n       }\r\n   \r\n       //% color=\"#009A00\" weight=30 block=\"(minimam 5cm) dstance |%limit| cm  |%nagasa| \" group=\"6 Ultrasonic_Distance sensor\"\r\n       //% limit.min=5 limit.max=30\r\n       //% advanced=true\r\n       export function sonar_ping_3(limit: number, nagasa: kyori): boolean {\r\n           let d1 = 0;\r\n           let d2 = 0;\r\n           /*if (limit < 5) {\r\n               limit = 5\r\n           }*/\r\n           for (let i = 0; i < 5; i++) {\r\n               // send\r\n               basic.pause(5);\r\n               pins.setPull(DigitalPin.P2, PinPullMode.PullNone);\r\n               pins.digitalWritePin(DigitalPin.P2, 0);\r\n               control.waitMicros(2);\r\n               pins.digitalWritePin(DigitalPin.P2, 1);\r\n               control.waitMicros(10);\r\n               pins.digitalWritePin(DigitalPin.P2, 0);\r\n               // read\r\n               d1 = pins.pulseIn(DigitalPin.P0, PulseValue.High, 500 * 58);\r\n               d2 = d1 + d2;\r\n           }\r\n           switch (nagasa) {\r\n               case kyori.short:\r\n                   if (Math.idiv(d2 / 5, 58) * 1.5 < limit) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n               case kyori.long:\r\n                   if (Math.idiv(d2 / 5, 58) * 1.5 < limit) {\r\n                       return false;\r\n                   } else {\r\n                       return true;\r\n                   }\r\n                   break;\r\n           }\r\n       }\r\n   \r\n   \r\n       //% color=\"#f071bd\" weight=30 blockId=auto_photo_R block=\"right_photoreflector\" group=\"7 photoreflector\"\r\n       //% advanced=true\r\n       export function phto_R() {\r\n           return Math.round((pins.analogReadPin(AnalogPin.P10) / 1023) * 100);\r\n       }\r\n   \r\n       //% color=\"#f071bd\" weight=28 blockId=auto_photo_L block=\"left_photoreflector\" group=\"7 photoreflector\"\r\n       //% advanced=true\r\n       export function phto_L() {\r\n           return Math.round((pins.analogReadPin(AnalogPin.P1) / 1023) * 100);\r\n       }\r\n   \r\n       //% color=\"#d4b41f\"  weight=26 block=\"right_photoreflector |%limit_R| small\" group=\"7 photoreflector\"\r\n       //% limit_R.min=0 limit_R.max=100\r\n       //% advanced=true\r\n       export function photo_R(limit_R: number): boolean {\r\n           if (plot.phto_R() <= limit_R) {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           if (plot.phto_L() <= limit_R) {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           io_neo.show()\r\n           if ((pins.analogReadPin(AnalogPin.P10) / 1023) * 100 < limit_R) {\r\n               return true;\r\n           } else {\r\n               return false;\r\n           }\r\n       }\r\n   \r\n       //% color=\"#d4b41f\"  weight=27 block=\"left_photoreflector |%limit_L| small\" group=\"7 photoreflector\"\r\n       //% limit_L.min=0 limit_L.max=100\r\n       //% advanced=true\r\n       export function photo_L(limit_L: number): boolean {\r\n           if (plot.phto_R() <= limit_L) {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           if (plot.phto_L() <= limit_L) {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           io_neo.show()\r\n           if ((pins.analogReadPin(AnalogPin.P1) / 1023) * 100 < limit_L) {\r\n               return true;\r\n           } else {\r\n               return false;\r\n           }\r\n       }\r\n   \r\n       //% color=\"#6041f1\"  weight=33 block=\"only right |%wb| stepping on  |%sikii| \" group=\"7 photoreflector\"\r\n       //% sence.min=10 sence.max=40\r\n       //% advanced=true\r\n       export function photo_R_out(wb: whiteblack, sikii: sence_select): boolean {\r\n           if (sikii == sence_select.Low_sensitivity) {\r\n               sikii1 = 60;\r\n           }\r\n           if (sikii == sence_select.normal30) {\r\n               sikii1 = 40;\r\n           }\r\n           if (sikii == sence_select.High_sensitivity) {\r\n               sikii1 = 20;\r\n           }\r\n           if (plot.phto_R() <= sikii1) {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           if (plot.phto_L() <= sikii1) {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           io_neo.show()\r\n           switch (wb) {\r\n               case whiteblack.black:\r\n                   if ((pins.analogReadPin(AnalogPin.P1) / 1023) * 100 > sikii1 && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 < sikii1) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n               case whiteblack.white:\r\n                   if ((pins.analogReadPin(AnalogPin.P1) / 1023) * 100 < sikii1 && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 > sikii1) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n           }\r\n       }\r\n   \r\n       //% color=\"#6041f1\"  weight=34 block=\"onle left |%wb| stepping on threshold |%sikii| \" group=\"7 photoreflector\" \r\n       //% advanced=true\r\n       export function photo_L_out(wb: whiteblack, sikii: sence_select): boolean {\r\n           if (sikii == sence_select.Low_sensitivity) {\r\n               sikii1 = 60;\r\n           }\r\n           if (sikii == sence_select.normal30) {\r\n               sikii1 = 40;\r\n           }\r\n           if (sikii == sence_select.High_sensitivity) {\r\n               sikii1 = 20;\r\n           }\r\n           if (plot.phto_R() <= sikii1) {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           if (plot.phto_L() <= sikii1) {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           io_neo.show()\r\n           switch (wb) {\r\n               case whiteblack.black:\r\n                   if (\r\n   \r\n                       (pins.analogReadPin(AnalogPin.P1) / 1023) * 100 < sikii1 && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 > sikii1) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n               case whiteblack.white:\r\n                   if ((pins.analogReadPin(AnalogPin.P1) / 1023) * 100 > sikii1 && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 < sikii1) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n           }\r\n       }\r\n       //% color=\"#6041f1\"  weight=35 block=\"Both |%wb| stepping on threshold threshold |%sikii| \" group=\"7 photoreflector\"\r\n       //% advanced=true\r\n       export function photo_LR_out(wb: whiteblack, sikii: sence_select): boolean {\r\n           if (sikii == sence_select.Low_sensitivity) {\r\n               sikii1 = 60;\r\n           }\r\n           if (sikii == sence_select.normal30) {\r\n               sikii1 = 40;\r\n           }\r\n           if (sikii == sence_select.High_sensitivity) {\r\n               sikii1 = 20;\r\n           }\r\n           if (plot.phto_R() <= sikii1) {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(1, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           if (plot.phto_L() <= sikii1) {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Green))\r\n           } else {\r\n               io_neo.setPixelColor(0, neopixel.colors(NeoPixelColors.Red))\r\n           }\r\n           io_neo.show()\r\n           switch (wb) {\r\n               case whiteblack.black:\r\n                   if (\r\n                       (pins.analogReadPin(AnalogPin.P1) / 1023) * 100 <= sikii1 && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 <= sikii1) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n   \r\n               case whiteblack.white:\r\n   \r\n                   if (\r\n                       (pins.analogReadPin(AnalogPin.P1) / 1023) * 100 >= sikii1 && (pins.analogReadPin(AnalogPin.P10) / 1023) * 100 >= sikii1) {\r\n                       return true;\r\n                   } else {\r\n                       return false;\r\n                   }\r\n                   break;\r\n           }\r\n   \r\n       }\r\n   \r\n       //% color=\"#009A00\"  weight=19 blockId=microbit2_decideLight block=\"m:bitOptical sensor value |%limit| Darker\" group=\"8 microbit Optical_sensor\"\r\n       //% limit.min=0 limit.max=100\r\n       //% advanced=true\r\n       export function microbit2_decideLight(limit: number): boolean {\r\n           if (input.lightLevel() / 254 * 100 < limit) {\r\n               return true;\r\n           } else {\r\n               return false;\r\n           }\r\n       }\r\n   \r\n   \r\n   \r\n       //% color=\"#009A00\"  weight=17 blockId=microbit2_denkitemp block=\"m:bitOptical sensor value\" group=\"8 microbit Optical_sensor\"\r\n       //% advanced=true\r\n       export function microbit2_denkitemp(): number {\r\n   \r\n           return Math.round(input.lightLevel() / 254 * 100);\r\n   \r\n       }\r\n   \r\n       /*\r\n           //% color=\"#228b22\"  weight=16 blockId=microbit2_denkiLED block=\"m:bit Optical sensor value\" group=\"8 microbit Optical_sensor\"\r\n           //% advanced=true\r\n           export function microbit2_denkiLED() {\r\n               basic.showNumber(Math.round(input.lightLevel() / 254 * 100));\r\n           }\r\n       */\r\n   \r\n   \r\n\r\n\r\n\r\n\r\n\r\n\r\n    /*\r\n        smbus.writeByte(0x81, 0x00)  //0x81=10000001  RGB timing 700ms\r\n        smbus.writeByte(0x81, 0x10)  //16×gain\r\n    \r\n        smbus.writeByte(0x80, 0x03)  //0x03を書くと動作開始\r\n        smbus.writeByte(0x81, 0x2b)  //this.addr 0x29 0x81=10000001 0x2b=00101011\r\n    */\r\n        smbus.writeByte(0x81, 0xF6)  //cycle10\r\n\r\n\r\n        smbus.writeByte(0x80, 0x03)  //0x03を書くと動作開始\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n        //% color=\"#ffa500\"  weight=35 block=\"values |%color|\" group=\"9 color senser\"\r\n        //% advanced=true\r\n        export function colorsenser_value(color:color_senser) :number{\r\n            switch (color){\r\n                case color_senser.Light:\r\n                    return color_L()\r\n                case color_senser.Red:\r\n                    return color_R()\r\n                case color_senser.Green:\r\n                    return color_G()                   \r\n                case color_senser.Blue:\r\n                    return color_B()\r\n            }\r\n        }\r\n    \r\n    \r\n        function color_R(){\r\n            return Math.round(rgb()[0] / Math.max(rgb()[0], Math.max(rgb()[1], rgb()[2]))*256)\r\n        }\r\n        function color_G(){\r\n            return Math.round(rgb()[1] / Math.max(rgb()[0], Math.max(rgb()[1], rgb()[2]))*256)\r\n        }\r\n        function color_B(){\r\n            return Math.round(rgb()[2] / Math.max(rgb()[0], Math.max(rgb()[1], rgb()[2]))*256)\r\n        }\r\n        function color_L(){\r\n            let result: Buffer = smbus.readBuffer(0xb4, pins.sizeOf(NumberFormat.UInt16LE) * 4)\r\n            return smbus.unpack(\"HHHH\", result)[0]/color_cycle*10\r\n        }\r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n    \r\n        export function rgb(): number[] {\r\n            let result: number[] = raw()\r\n            let clear: number = result.shift()\r\n            for (let x: number = 0; x < result.length; x++) {\r\n                result[x] = result[x] * 255 / clear\r\n            }\r\n            return result\r\n        }\r\n    \r\n    \r\n        export function raw(): number[] {\r\n    \r\n            let result: Buffer = smbus.readBuffer(0xb4, pins.sizeOf(NumberFormat.UInt16LE) * 4)\r\n            return smbus.unpack(\"HHHH\", result)\r\n        }\r\n    \r\n    \r\n        //% color=\"#ffa500\"  weight=16 blockId=color_temp block=\"color Temperatures value\" group=\"9 color senser\"\r\n        //% advanced=true\r\n        export function color_temp(): number {\r\n            return Math.round(3810 * color_B() / color_R() + 1391)\r\n        }\r\n    \r\n    \r\n        //% color=\"#ffa500\" weight=88 blockId=selectcycle\r\n        //% block=\"choice |%cycle|\" group=\"9 color senser\"\r\n        //% advanced=true\r\n        export function selectcycle(cycle: colorcycle): void {\r\n            \r\n            switch (cycle) {\r\n                case colorcycle.cycle1:\r\n                    color_cycle = 1\r\n                    smbus.writeByte(0x81, 0xFF)\r\n                    break;\r\n                case colorcycle.cycle10:\r\n                    color_cycle = 10\r\n                    smbus.writeByte(0x81, 0xF6)\r\n                    break;\r\n                case colorcycle.cycle42:\r\n                    color_cycle = 42\r\n                    smbus.writeByte(0x81, 0xD5)\r\n                    break;\r\n                case colorcycle.cycle64:\r\n                    color_cycle = 64\r\n                    smbus.writeByte(0x81, 0xC0)\r\n                    break;\r\n            }\r\n        }\r\n    \r\n    \r\n    \r\n        //% color=\"#ffa500\"  weight=16 blockId=color_ID block=\"color ID\" group=\"9 color senser\"\r\n        //% advanced=true\r\n        export function color_ID(): number {\r\n            /*     黒:0　　赤：1　緑：2　青：3　白:4  */\r\n            let color_ID = 0\r\n            neo_sinamon.showColor(neopixel.colors(NeoPixelColors.Black))\r\n            let R = color_R()\r\n            let G = color_G()\r\n            let B = color_B()\r\n            let L = color_L()\r\n            let maxcolor_value = Math.max(R, Math.max(G, B))\r\n            if (L >50  &&  L <= 200 ){\r\n                if (maxcolor_value == R) {\r\n                    color_ID = 1\r\n                }\r\n                if (maxcolor_value == G) {\r\n                    color_ID = 2\r\n                }\r\n                if (maxcolor_value == B) {\r\n                    color_ID = 3\r\n                }\r\n\r\n            }\r\n            else{\r\n                if (L > 200 ){\r\n                    color_ID = 4\r\n                }\r\n                else{\r\n                    color_ID = 0\r\n                }\r\n                \r\n            }               \r\n        return (color_ID) ;\r\n        }\r\n    \r\n    \r\n    \r\n        //% color=\"#ffa500\"  weight=14 block=\"|%scene|color \" group=\"9 color senser\"\r\n        //% advanced=true\r\n        export function color1(scene : color_scene ): boolean {\r\n    \r\n            switch (scene) {\r\n                case color_scene.Red:\r\n                    if (color_ID() == 1) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                case color_scene.Green:\r\n                    if (color_ID() == 2) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                case color_scene.Blue:\r\n                    if (color_ID() == 3) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                case color_scene.White:\r\n                    if (color_ID() == 4) {\r\n                        return true;\r\n                    } else {\r\n                        return false;\r\n                    }\r\n                    break;    \r\n            }\r\n        }\r\n    \r\n    \r\n    \r\n    \r\n        namespace smbus {\r\n            export function writeByte(register: number, value: number): void {\r\n                let temp = pins.createBuffer(2);\r\n                temp[0] = register;\r\n                temp[1] = value;\r\n                pins.i2cWriteBuffer(0x29, temp, false);\r\n            }\r\n    \r\n    \r\n            export function readBuffer(register: number, len: number): Buffer {\r\n                let temp = pins.createBuffer(1);\r\n                temp[0] = register;\r\n                pins.i2cWriteBuffer(0x29, temp, false);\r\n                return pins.i2cReadBuffer(0x29, len, false);\r\n            }\r\n    \r\n    \r\n            export function unpack(fmt: string, buf: Buffer): number[] {\r\n                let le: boolean = true;\r\n                let offset: number = 0;\r\n                let result: number[] = [];\r\n                let num_format: NumberFormat = 0;\r\n                for (let c = 0; c < fmt.length; c++) {\r\n                    switch (fmt.charAt(c)) {\r\n                        case '<':\r\n                            le = true;\r\n                            continue;\r\n                        case '>':\r\n                            le = false;\r\n                            continue;\r\n                        case 'c':\r\n                        case 'B':\r\n                            num_format = le ? NumberFormat.UInt8LE : NumberFormat.UInt8BE; break;\r\n                        case 'b':\r\n                            num_format = le ? NumberFormat.Int8LE : NumberFormat.Int8BE; break;\r\n                        case 'H':\r\n                            num_format = le ? NumberFormat.UInt16LE : NumberFormat.UInt16BE; break;\r\n                        case 'h':\r\n                            num_format = le ? NumberFormat.Int16LE : NumberFormat.Int16BE; break;\r\n                    }\r\n                    result.push(buf.getNumber(num_format, offset));\r\n                    offset += pins.sizeOf(num_format);\r\n                }\r\n                return result;\r\n            }\r\n        }\r\n    \r\n\r\n      \r\n        loops.everyInterval(10, function () {\r\n            if (con_ope == 1) {\r\n                plot.car_zengo(plot.plotter_houkou.forward, 0.5)\r\n            }\r\n            if (con_ope == 2) {\r\n                plot.car_zengo(plot.plotter_houkou.backward, 0.5)\r\n            }\r\n            if (con_ope == 3) {\r\n                plot.car_RL_cycle(1, plot.plotter_RL.right)\r\n            }\r\n            if (con_ope == 4) {\r\n                plot.car_RL_cycle(1, plot.plotter_RL.left)\r\n            }\r\n            if (con_ope == 5) {\r\n                plot.car_L_step(plot.plotter_houkou.forward, 4)\r\n            }\r\n            if (con_ope == 6) {\r\n                plot.car_R_step(plot.plotter_houkou.forward, 4)\r\n            }\r\n        })\r\n\r\n\r\n/*\r\nconst OPERATIONS = {\r\n    FORWARD: 1,\r\n    BACKWARD: 2,\r\n    RIGHT_CYCLE: 3,\r\n    LEFT_CYCLE: 4,\r\n    LEFT_STEP: 5,\r\n    RIGHT_STEP: 6\r\n  };\r\n  \r\n  function performOperation(ope) {\r\n    switch (ope) {\r\n      case OPERATIONS.FORWARD:\r\n        plot.car_zengo(plot.plotter_houkou.forward, 0.1);\r\n        break;\r\n      case OPERATIONS.BACKWARD:\r\n        plot.car_zengo(plot.plotter_houkou.backward, 0.1);\r\n        break;\r\n      case OPERATIONS.RIGHT_CYCLE:\r\n        plot.car_RL_cycle(1, plot.plotter_RL.right);\r\n        break;\r\n      case OPERATIONS.LEFT_CYCLE:\r\n        plot.car_RL_cycle(1, plot.plotter_RL.left);\r\n        break;\r\n      case OPERATIONS.LEFT_STEP:\r\n        plot.car_L_step(plot.plotter_houkou.forward, 4);\r\n        break;\r\n      case OPERATIONS.RIGHT_STEP:\r\n        plot.car_R_step(plot.plotter_houkou.forward, 4);\r\n        break;\r\n      default:\r\n        // 未知の操作に対する処理\r\n        break;\r\n    }\r\n  }\r\n  \r\n  loops.everyInterval(10, function () {\r\n    if (con_ope in OPERATIONS) {\r\n      performOperation(con_ope);\r\n    } else {\r\n      // 未知の操作に対する処理\r\n    }\r\n  });\r\n  */\r\n   \r\n}\r\n    \r\n\r\n    \r\n\r\n//% color=\"#ff4500\" weight=94 block=\"Plotcar_LED\"\r\n   \r\nnamespace plotLED_blocks {\r\n   \r\n\r\n\r\n    //% color=\"#000000\" weight=80 blockId=neopixel_erace block=\"Color LED(s) off\" group=\"color LED\"\r\n    export function neopixel_erace_block() {\r\n        for (let n = 0; n < 4 ; n++) {\r\n            io_neo.setPixelColor(n, neopixel.colors(NeoPixelColors.Black))\r\n        }\r\n        io_neo.show()\r\n    }\r\n\r\n    //% color=\"#708090\" weight=78 blockId=neopixel_Brightness block=\"Color LED(s) Brightness|%neo_Brightness| \" group=\"color LED\"\r\n    //% neo_Brightness.min=0 neo_Brightness.max=255 neo_Brightness.defl=255\r\n    export function neopixel_Brightness_block(neo_Brightness: number) {\r\n        io_neo.setBrightness(neo_Brightness)\r\n    }\r\n\r\n    //% color.shadow=\"colorNumberPicker\"\r\n    //% color=\"#708090\" weight=76 blockId=neopixel_set block=\"No.|%neo_number|LED ON  color $color\" group=\"color LED\"\r\n    //% neo_number.min=0 neo_number.max=3 neo_number.defl=0\r\n    export function neopixel_set_block(neo_number: number, color: number) {\r\n        io_neo.setPixelColor(neo_number, color)\r\n        io_neo.show()\r\n    }\r\n\r\n\r\n    //% color.shadow=\"colorNumberPicker\"\r\n    //% color=\"#708090\" weight=74 blockId=neopixel_select block=\"|%neo_number|LED(s) ON   color $color\" group=\"color LED\"\r\n    //% neo_number.min=0 neo_number.max=4 neo_number.defl=4\r\n    export function neopixel_select_block(neo_number: number, color: number) {\r\n        for (let n = 0; n < 4; n++) {\r\n            io_neo.setPixelColor(n, neopixel.colors(NeoPixelColors.Black))\r\n        }\r\n        io_neo.show()\r\n        for (let n = 0; n < neo_number; n++) {\r\n            io_neo.setPixelColor(n, color)\r\n        }\r\n        io_neo.show()\r\n\r\n    }\r\n\r\n    //% color=\"#708090\" weight=72 blockId=neopixel_reinbow block=\"RGB on\" group=\"color LED\"\r\n    export function neopixel_rainbow() {\r\n        io_neo.showRainbow(1, 180)\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    }\r\n   \r\n   \r\n   \r\n   \r\n   ","pxt.json":"{\n    \"name\": \"plotcarv36\",\n    \"version\": \"0.0.0\",\n    \"description\": \"\",\n    \"dependencies\": {\n        \"core\": \"*\",\n        \"neopixel\": \"github:Microsoft/pxt-neopixel#v0.7.3\"\n    },\n    \"files\": [\n        \"README.md\",\n        \"main.blocks\",\n        \"main.ts\",\n        \"plotcarv36.ts\",\n        \"_locales/ja/plotcarv36-strings.json\"\n    ],\n    \"testFiles\": [\n        \"test.ts\"\n    ],\n    \"public\": true,\n    \"targetVersions\": {\n        \"target\": \"4.0.18\",\n        \"targetId\": \"microbit\"\n    },\n    \"supportedTargets\": [\n        \"microbit\"\n    ],\n    \"preferredEditor\": \"tsprj\"\n}\n","test.ts":"// テストはここに来ます。このパッケージが拡張機能として使用されるときにはコンパイルされません。\r\n"}